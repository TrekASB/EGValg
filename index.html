<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Property-verdi kakediagram (opptil 4)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Trimble Connect Workspace API -->
  <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    header .title {
      font-weight: 600;
      margin-right: 8px;
      white-space: nowrap;
    }

    header button {
      font-size: 13px;
      padding: 4px 8px;
      cursor: pointer;
      white-space: nowrap;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 12px;
      box-sizing: border-box;
      gap: 8px;
    }

    #status {
      font-size: 13px;
      opacity: 0.9;
      min-height: 18px;
    }

    #error {
      font-size: 13px;
      color: #b00020;
      min-height: 18px;
    }

    #configContainer {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 13px;
      margin-top: 4px;
    }

    .config-row {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 6px;
      background: #f5f5f5;
    }

    .config-label {
      font-weight: 600;
      margin-right: 4px;
    }

    .config-row label {
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    .config-row select {
      font-size: 13px;
      padding: 2px 4px;
      max-width: 210px;
    }

    #chartsWrapper {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 8px;
    }

    .chart-card {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: #fff;
      min-height: 220px;
    }

    .chart-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      flex-wrap: wrap;
    }

    .chart-title {
      font-weight: 600;
    }

    .chart-card-header button {
      font-size: 12px;
      padding: 3px 8px;
      cursor: pointer;
      white-space: nowrap;
    }

    .chart-info {
      font-size: 12px;
      opacity: 0.9;
      min-height: 16px;
    }

    canvas {
      max-width: 480px;
      max-height: 480px;
      width: 100%;
      height: auto;
    }
  </style>
</head>
<body>
  <header>
    <div class="title">Property-verdi kakediagram (opptil 4)</div>
    <button id="scanButton">Oppdater liste fra modell</button>
    <button id="reloadButton" disabled>Hent fra modell</button>
  </header>

  <main>
    <div id="status">Kobler til Trimble Connect…</div>

    <div id="configContainer">
      <div class="config-row" data-slot="0">
        <span class="config-label">Oppsett 1:</span>
        <label>
          Property set:
          <select class="pset-select" id="psetSelect-0" data-slot="0">
            <option value="">(velg…)</option>
          </select>
        </label>
        <label>
          Property:
          <select class="prop-select" id="propSelect-0" data-slot="0" disabled>
            <option value="">(velg…)</option>
          </select>
        </label>
      </div>

      <div class="config-row" data-slot="1">
        <span class="config-label">Oppsett 2:</span>
        <label>
          Property set:
          <select class="pset-select" id="psetSelect-1" data-slot="1">
            <option value="">(velg…)</option>
          </select>
        </label>
        <label>
          Property:
          <select class="prop-select" id="propSelect-1" data-slot="1" disabled>
            <option value="">(velg…)</option>
          </select>
        </label>
      </div>

      <div class="config-row" data-slot="2">
        <span class="config-label">Oppsett 3:</span>
        <label>
          Property set:
          <select class="pset-select" id="psetSelect-2" data-slot="2">
            <option value="">(velg…)</option>
          </select>
        </label>
        <label>
          Property:
          <select class="prop-select" id="propSelect-2" data-slot="2" disabled>
            <option value="">(velg…)</option>
          </select>
        </label>
      </div>

      <div class="config-row" data-slot="3">
        <span class="config-label">Oppsett 4:</span>
        <label>
          Property set:
          <select class="pset-select" id="psetSelect-3" data-slot="3">
            <option value="">(velg…)</option>
          </select>
        </label>
        <label>
          Property:
          <select class="prop-select" id="propSelect-3" data-slot="3" disabled>
            <option value="">(velg…)</option>
          </select>
        </label>
      </div>
    </div>

    <div id="error"></div>

    <div id="chartsWrapper">
      <!-- Diagram-kort genereres dynamisk -->
    </div>
  </main>

  <script>
    let API = null;

    // psetNavn -> Set(propertyNavn)
    let availableProps = {};

    // Alle objekt-egenskaper lagres for gjenbruk:
    // [
    //   { modelId, objects: [ { runtimeId, properties:[pset,...] } ] }
    // ]
    let lastAllObjects = null;

    // Per slot: selectionByState
    // withValue / withoutValue → modelId → [runtimeIds]
    let selectionStatesBySlot = {};

    // Per slot: Chart.js-instans
    let chartInstances = {};

    // Farger
    const GROUP_COLORS = {
      withValue: "rgb(55, 130, 70)",     // Med verdi
      withoutValue: "rgb(200, 60, 60)"   // Uten verdi
    };

    // Enkel parser for "rgb(r,g,b)" → {r,g,b,a}
    function parseRgbToRgba(rgbString) {
      if (!rgbString) return null;
      const start = rgbString.indexOf("(");
      const end = rgbString.indexOf(")");
      if (start === -1 || end === -1) return null;
      const parts = rgbString.slice(start + 1, end).split(",");
      if (parts.length !== 3) return null;
      const nums = parts.map(p => parseInt(p.trim(), 10));
      if (nums.some(n => isNaN(n))) return null;
      const [r, g, b] = nums;
      return { r, g, b, a: 255 };
    }

    async function connectToWorkspace() {
      API = await TrimbleConnectWorkspace.connect(
        window.parent,
        (event, data) => {
          console.log("TC event:", event, data);
        },
        30000
      );
      document.getElementById("status").textContent =
        "Tilkoblet. Klikk «Oppdater liste fra modell».";
    }

    function setButtonsEnabled(afterScan) {
      document.getElementById("reloadButton").disabled = !afterScan;
    }

    async function getAllObjectProperties() {
      if (!API) throw new Error("API ikke tilkoblet.");

      const modelObjectsList = await API.viewer.getObjects();
      console.log("getObjects() →", modelObjectsList);

      const result = [];

      for (const modelObjects of modelObjectsList) {
        const modelId =
          modelObjects.modelId ||
          modelObjects.modelid ||
          modelObjects["model Id"];

        const objs = modelObjects.objects || [];
        if (!modelId || !objs.length) continue;

        const runtimeIds = objs.map(o => o.id);
        if (!runtimeIds.length) continue;

        const objectPropsArray = await API.viewer.getObjectProperties(
          modelId,
          runtimeIds
        );

        const objects = objectPropsArray.map(obj => ({
          runtimeId: obj.id,
          properties: obj.properties || []
        }));

        result.push({ modelId, objects });
      }

      return result;
    }

    function populateAllPsetSelects() {
      const psetSelects = document.querySelectorAll(".pset-select");
      const propSelects = document.querySelectorAll(".prop-select");

      // nullstill property-selects
      propSelects.forEach(sel => {
        sel.innerHTML = '<option value="">(velg…)</option>';
        sel.disabled = true;
      });

      const psetNames = Object.keys(availableProps).sort((a, b) =>
        a.localeCompare(b, "nb")
      );

      psetSelects.forEach(select => {
        const prev = select.value;
        select.innerHTML = '<option value="">(velg…)</option>';
        for (const name of psetNames) {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          select.appendChild(opt);
        }
        if (psetNames.includes(prev)) {
          select.value = prev;
        }
      });
    }

    function populatePropSelectForSlot(slotIndex, psetName) {
      const propSelect = document.getElementById("propSelect-" + slotIndex);
      if (!propSelect) return;

      propSelect.innerHTML = '<option value="">(velg…)</option>';

      if (!psetName || !availableProps[psetName]) {
        propSelect.disabled = true;
        return;
      }

      const props = Array.from(availableProps[psetName]).sort((a, b) =>
        a.localeCompare(b, "nb")
      );

      for (const p of props) {
        const opt = document.createElement("option");
        opt.value = p;
        opt.textContent = p;
        propSelect.appendChild(opt);
      }

      propSelect.disabled = false;
    }

    async function scanAvailableProperties() {
      if (!API) throw new Error("API ikke tilkoblet.");

      const statusEl = document.getElementById("status");
      const errorEl = document.getElementById("error");
      errorEl.textContent = "";

      statusEl.textContent = "Skanner modellen for PropertySets og Properties…";

      availableProps = {};
      lastAllObjects = await getAllObjectProperties();

      // Bygg liste over alle PSets / Properties
      for (const model of lastAllObjects) {
        for (const obj of model.objects) {
          const psets = obj.properties || [];
          for (const pset of psets) {
            const psetName = pset.name || "";
            if (!psetName) continue;

            if (!availableProps[psetName]) {
              availableProps[psetName] = new Set();
            }

            const props = pset.properties || [];
            for (const p of props) {
              const propName = p.name || "";
              if (!propName) continue;
              availableProps[psetName].add(propName);
            }
          }
        }
      }

      populateAllPsetSelects();

      statusEl.textContent =
        "PropertySets og Properties er oppdatert. Velg inntil 4 oppsett og trykk «Hent fra modell».";
      setButtonsEnabled(true);
    }

    function computeCountsForConfig(allObjects, selectedPset, selectedProp) {
      const counts = { withValue: 0, withoutValue: 0 };
      const selectionByState = { withValue: {}, withoutValue: {} };

      for (const model of allObjects) {
        const modelId = model.modelId;
        for (const obj of model.objects) {
          const psets = obj.properties || [];
          let hasProperty = false;
          let hasValue = false;

          for (const pset of psets) {
            if (pset.name !== selectedPset) continue;

            const props = pset.properties || [];
            for (const p of props) {
              if (p.name !== selectedProp) continue;

              hasProperty = true;
              const v = p.value;
              if (v !== null && v !== undefined && String(v).trim() !== "") {
                hasValue = true;
              }
              break;
            }
            if (hasProperty) break;
          }

          const stateKey = (hasProperty && hasValue) ? "withValue" : "withoutValue";
          counts[stateKey]++;

          if (!selectionByState[stateKey][modelId]) {
            selectionByState[stateKey][modelId] = [];
          }
          selectionByState[stateKey][modelId].push(obj.runtimeId);
        }
      }

      return { counts, selectionByState };
    }

    async function applyPropertyColors(selectionByState) {
      if (!API) throw new Error("API ikke tilkoblet.");

      const statusEl = document.getElementById("status");
      const errorEl = document.getElementById("error");
      errorEl.textContent = "";
      statusEl.textContent = "Fargelegger objekter i modellen…";

      try {
        // Reset alle farger
        await API.viewer.setObjectState(undefined, { color: "reset" });

        for (const stateKey of ["withValue", "withoutValue"]) {
          const perModel = selectionByState[stateKey];
          if (!perModel) continue;

          const modelObjectIds = [];
          for (const modelId in perModel) {
            const ids = perModel[modelId];
            if (ids && ids.length) {
              modelObjectIds.push({
                modelId: modelId,
                objectRuntimeIds: ids
              });
            }
          }

          if (!modelObjectIds.length) continue;

          const colorString = GROUP_COLORS[stateKey];
          const rgba = parseRgbToRgba(colorString);
          if (!rgba) continue;

          const selector = { modelObjectIds: modelObjectIds };

          await API.viewer.setObjectState(selector, {
            color: rgba
          });
        }

        statusEl.textContent = "Fargelegging i modellen er oppdatert.";
      } catch (err) {
        console.error("Feil ved fargelegging:", err);
        errorEl.textContent =
          "Feil ved fargelegging av objekter: " + (err.message || err);
      }
    }

    function renderPieChartForSlot(slotIndex, counts, config) {
      const chartsWrapper = document.getElementById("chartsWrapper");
      const pset = config.pset;
      const prop = config.prop;
      const total = (counts.withValue || 0) + (counts.withoutValue || 0);

      let card = document.querySelector('.chart-card[data-slot="' + slotIndex + '"]');

      if (!card) {
        card = document.createElement("div");
        card.className = "chart-card";
        card.setAttribute("data-slot", slotIndex);

        const headerDiv = document.createElement("div");
        headerDiv.className = "chart-card-header";

        const titleSpan = document.createElement("span");
        titleSpan.className = "chart-title";
        headerDiv.appendChild(titleSpan);

        const btn = document.createElement("button");
        btn.className = "colorize-button";
        btn.textContent = "Fargelegg objekter";
        btn.setAttribute("data-slot", slotIndex);
        headerDiv.appendChild(btn);

        card.appendChild(headerDiv);

        const canvas = document.createElement("canvas");
        canvas.id = "chartCanvas-" + slotIndex;
        card.appendChild(canvas);

        const infoDiv = document.createElement("div");
        infoDiv.className = "chart-info";
        infoDiv.id = "chartInfo-" + slotIndex;
        card.appendChild(infoDiv);

        chartsWrapper.appendChild(card);

        btn.addEventListener("click", function (e) {
          const slot = e.target.getAttribute("data-slot");
          const selectionByState = selectionStatesBySlot[slot];
          if (!selectionByState) {
            document.getElementById("error").textContent =
              "Ingen data for dette oppsettet ennå. Trykk «Hent fra modell» først.";
            return;
          }
          applyPropertyColors(selectionByState);
        });
      }

      const titleSpan = card.querySelector(".chart-title");
      const infoDiv = card.querySelector(".chart-info");
      const ctx = card.querySelector("canvas").getContext("2d");

      titleSpan.textContent =
        "Oppsett " + (Number(slotIndex) + 1) + ": " + pset + " / " + prop;

      if (chartInstances[slotIndex]) {
        chartInstances[slotIndex].destroy();
      }

      if (total === 0) {
        infoDiv.textContent =
          "Ingen objekter med valgt PropertySet/Property i modellen.";
        chartInstances[slotIndex] = null;
        return;
      }

      const labels = ["Med verdi", "Uten verdi"];
      const data = [counts.withValue || 0, counts.withoutValue || 0];
      const backgroundColors = [
        GROUP_COLORS.withValue,
        GROUP_COLORS.withoutValue
      ];

      chartInstances[slotIndex] = new Chart(ctx, {
        type: "pie",
        data: {
          labels: labels,
          datasets: [
            {
              data: data,
              backgroundColor: backgroundColors
            }
          ]
        },
        options: {
          plugins: {
            tooltip: {
              callbacks: {
                label: function (context) {
                  const label = context.label || "";
                  const value = context.parsed || 0;
                  const percent = total > 0
                    ? ((value / total) * 100).toFixed(1)
                    : 0;
                  return label + ": " + percent + " % (" + value + " objekter)";
                }
              }
            },
            legend: {
              position: "bottom",
              labels: {
                generateLabels: function (chartInstance) {
                  const dataSet = chartInstance.data.datasets[0];
                  const labels = chartInstance.data.labels || [];
                  return labels.map(function (label, i) {
                    const value = dataSet.data[i];
                    const percent = total > 0
                      ? ((value / total) * 100).toFixed(1)
                      : 0;
                    return {
                      text: label + " – " + percent + " % (" + value + " objekter)",
                      fillStyle: dataSet.backgroundColor[i],
                      strokeStyle: dataSet.backgroundColor[i],
                      lineWidth: 1,
                      hidden: false,
                      index: i
                    };
                  });
                }
              }
            }
          }
        }
      });

      infoDiv.textContent =
        "Med verdi: " + counts.withValue +
        " – Uten verdi: " + counts.withoutValue +
        " – Totalt: " + total + " objekter.";
    }

    async function loadCharts() {
      const statusEl = document.getElementById("status");
      const errorEl = document.getElementById("error");
      const chartsWrapper = document.getElementById("chartsWrapper");

      errorEl.textContent = "";
      chartsWrapper.innerHTML = "";
      chartInstances = {};
      selectionStatesBySlot = {};

      const configs = [];
      for (let slot = 0; slot < 4; slot++) {
        const pset = document.getElementById("psetSelect-" + slot).value;
        const prop = document.getElementById("propSelect-" + slot).value;
        if (pset && prop) {
          configs.push({ slot: slot, pset: pset, prop: prop });
        }
      }

      if (configs.length === 0) {
        errorEl.textContent =
          "Velg minst én PropertySet/Property-kombinasjon før du henter fra modellen.";
        return;
      }

      statusEl.textContent =
        "Leser property-verdier for " + configs.length + " oppsett…";

      try {
        let allObjects = lastAllObjects;
        if (!allObjects) {
          allObjects = await getAllObjectProperties();
          lastAllObjects = allObjects;
        }

        for (const cfg of configs) {
          const result = computeCountsForConfig(
            allObjects,
            cfg.pset,
            cfg.prop
          );
          selectionStatesBySlot[cfg.slot] = result.selectionByState;
          renderPieChartForSlot(cfg.slot, result.counts, cfg);
        }

        statusEl.textContent =
          "Diagram oppdatert for " + configs.length +
          " oppsett. Bruk «Fargelegg objekter» på hvert kort for å se fordelingen i modellen.";
      } catch (err) {
        console.error(err);
        errorEl.textContent =
          "Feil ved lesing av property-data: " + (err.message || err);
        statusEl.textContent = "Kunne ikke oppdatere diagram.";
      }
    }

    // Event handlers
    document.getElementById("scanButton").addEventListener("click", function () {
      scanAvailableProperties().catch(function (err) {
        console.error(err);
        document.getElementById("error").textContent =
          "Feil ved scanning av modellen: " + (err.message || err);
      });
    });

    document.getElementById("reloadButton").addEventListener("click", function () {
      loadCharts();
    });

    document.querySelectorAll(".pset-select").forEach(function (select) {
      select.addEventListener("change", function (e) {
        const slot = e.target.getAttribute("data-slot");
        const psetName = e.target.value;
        populatePropSelectForSlot(slot, psetName);
      });
    });

    // Init – koble til Workspace
    (async function () {
      try {
        await connectToWorkspace();
        setButtonsEnabled(false);
      } catch (err) {
        console.error(err);
        document.getElementById("error").textContent =
          "Klarte ikke å koble til Workspace API: " + (err.message || err);
        document.getElementById("status").textContent = "Feil.";
      }
    })();
  </script>
</body>
</html>
